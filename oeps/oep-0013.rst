====================================
OEP-13: Open edX web API conventions
====================================

.. This is the template to use when you start a new OEP.

+---------------+-------------------------------------------+
| OEP           | :doc:`OEP-13 </oeps/oep-0013>`            |
+---------------+-------------------------------------------+
| Title         | Open edX web API conventions              |
+---------------+-------------------------------------------+
| Last Modified | 2016-12-29                                |
+---------------+-------------------------------------------+
| Author        | Edward Fagin <eddie@edx.org>              |
+---------------+-------------------------------------------+
| Arbiter       |                                           |
+---------------+-------------------------------------------+
| Status        | Draft                                     |
+---------------+-------------------------------------------+
| Type          | Best Practice                             |
+---------------+-------------------------------------------+
|  Created      | 2016-12-29                                |
+---------------+-------------------------------------------+
| `Resolution`  |                                           |
+---------------+-------------------------------------------+
| `Replaces`    |                                           |
+---------------+-------------------------------------------+
| `Replaced-By` |                                           |
+---------------+-------------------------------------------+
| `References`  |                                           |
+---------------+-------------------------------------------+

Abstract
========

This document captures the conventions to be used for all Open edX web APIs.

Motivation
==========

The Open edX platform contains many extension points for third-party developers that wish to integrate with the platform. We wish to approach a standard methodology for API design in order to give developers more consistency in their API client design, and to make our endpoint behaviors more predictable.

Specification
=============

.. The specification describes the technical details of the Architecture, Best
.. Practice, Process or Product Enhancement proposed by the OEP. If the proposal
.. includes a new API, specify its syntax and semantics.

High level considerations
-------------------------

**Consistent interface**

All Open edX web APIs should use JSON as the data exchange format, and follow `RESTful API conventions <https://en.wikipedia.org/wiki/Representational_state_transfer>`_ where possible.


**Consumer perspective**

Design your API from the perspective of the consumer, NOT the perspective of your underlying implementation.  For example:

    - If the underlying implementation requires accessing multiple models or multiple apps/projects, this does not need to be reflected in a public interface.  From the perspective of the consumer, it's simply one thing they are requesting.

    - Keep CRUD operations together within its corresponding resource.  Why have the client go to one resource to read it and then another resource to write it?

**Simple**

Keep the top-leveI resources clear and simple - focusing on what the client is looking to consume.  You can hide complexity within the parameters.


**Discoverable**

Support `HATEOAS <https://en.wikipedia.org/wiki/HATEOAS>`_ where possible.  This allows us to change our URLs without needing to worry about updating the mobile apps if the app discovers its URLs from a base URL.


**Separate concerns**

Do not require the consumer to know any implementation details.  For example, an API shouldn't require the client to know the inter-dependencies of fields.  Rather, all such business rules should be owned by the server.  This allows the client to be lightweight and easily maintainable in the future.


**Conservative publishing**

Keep your just implemented endpoint "private" until it has been field tested for a few months before you publish it to read-the-docs.  Once published, while you may have a deprecation strategy, you have committed to support that endpoint indefinitely for the foreseeable future - especially if it's used by mobile clients or external partners.


URL naming
----------

*Must*: Keep your base URL simple and intuitive.  

    Suggestion: Follow this basic URL structure if you are concerned about collisions within your service. ::

        /api/{API_NAME}/{VERSION}/...

    If collisions are not a concern (for example, when exposing APIs from context-specific IDAs), then you can eliminate the use of API_NAME. ::

        /api/{VERSION}/...

*Must*: Keep the API name flat.  Use two base URLs per resource: collection/identifier, e.g. ::

    /api/user/v1/accounts/{USERNAME}

*It is not necessary that there is a one-to-one correspondence between an API and the Django app that provides it.  In fact, which Django app implements an API is an implementation detail and need not be bound to a public interface.*

**Resource name**

- Keep verbs out of the base URL
- *Must*: Use plural rather than singular nouns
- *Must*: Use concrete (e.g., blogs, videos, news) rather than abstract (e.g., items, assets) names
- *Must*: Use Python conventions: use_underscores instead of CamelCase

**Verbs**

- When no resource is involved, be direct and use Verbs instead of Nouns.  But only when absolutely necessary as we try to use nouns as much as possible. ::

    /convert?from=EUR&to=CNY&amount=100

- Make it clear in your API documentation that these “non-resource” scenarios are different.

Identifying resources
---------------------

*Nice*: Do not expose database IDs where possible (*Must* for external APIs, per dev ops)

*Must*: edX resource identifiers

- Users should be referenced by username
- Courses should be referenced via course keys
- Course blocks should be referenced via usage keys

**Explicit Filters**

- Model system resource URL schemes as if all resources are available to all users

- Include all necessary filters in the URL such that any user could theoretically access the resource

- Separate filtering and authorization – ie, do not return different resource representations via the same URL based on the requesting user 

    Example 1:  ``/profiles/john_harvard`` versus ``/profile``

    Example 2:  ``/courses?username=john_harvard`` versus ``/courses``

- Remember, it's entirely possible that ``/profiles/john_harvard`` or ``/courses?username=john_harvard`` could be requested by an "administrator" user

- Several benefits exist from an explicit filtering approach:

    - Ensures resources/results are individually-addressable
    - Enables discovery/sharing of resources, among other potential uses
    - Resource filtering mechanisms can be modified without impacting authorization mechanisms
    - Intermediate network gear can cache resource representations to improve performance (for open/unprotected resources)


**Composite Resource** (with multiple dimensions)

If an endpoint represents a relationship among multiple dimensions, the dimensions can be specified in the following ways:

    - As filter parameters: ::

        /api/enrollments/v1/enrollments/?user={username}&course={course_id}

    - As comma-delimited resource keys in the URL: ::

        /api/enrollments/v1/enrollments/{username},{course_id}

    - As UUIDs to uniquely identify the relationship: ::

        /api/enrollments/v1/enrollments/{enrollment_id}


HTTP verbs
----------

Use HTTP verbs to operate on the collections and resources.

**"Safe"** operations (*Must not*: modify any resource's state)

- ``GET`` - Filter a collection down to a set of resources matching the provided criteria ::

    /users
    /users/:id
    /users?last_name=Smith

**State-modyfing** operations

- ``POST`` - Submit information about a resource to the service for processing

    - Typically utilized for resource creation workflows ::

        POST /users   {user_data}

    - Other cases include establishing a link between two resources ::

        POST /users/:id/groups  {group_id}

- ``PATCH`` - Modify an existing resource

    - Return value must be 204 with no additional content. 
    - If implementing the simpler `"merge patch" algorithm <https://tools.ietf.org/html/rfc7396>`_, the content_type of ``application/merge-patch+json`` should be used to differentiate from the full `JSON Patch specification <http://tools.ietf.org/html/rfc6902>`_.
    - See the note below for more information on ``PATCH``.

- ``PUT`` - Replace a resource in entirety.  

    - Most use cases can be solved using partial updates via ``PATCH``
    - ``PUT`` can be used if a complete update of the resource, including all of its sub-resources, is desired. 
    - A typical ``PUT`` use case:  The resource is a singular primitive value addressable via URI, such as when updating the value for a particular User Preference.

- ``DELETE`` - Remove a resource (or a relationship) from the system

    - **Must** return ``HTTP 204 No Content`` ::

        DELETE /users/:id
        DELETE /users/:id/groups/:group_id

**A note on HTTP PATCH**

"Plain" HTTP PATCH (RFC 5789) is neutral with respect to content type and only specifies that the request body provide instructions for how to update the resource in question, not the format of those instructions.  Several flavors of PATCH specific to JSON documents have more explicit definition, as noted above.


In DRF, the default PATCH handling fairly closely resembles what is specified by merge patch, but it does not require (or understand) the ``application/merge-patch+json`` media type.  In edX REST APIs, if an implementation will use DRF's default PATCH handling, the implementation MUST recognize and accept the merge patch media type; API clients SHOULD use this media type, preferring it to the more typical ``application/json`` type.

The reason for this stricture is to explicitly leave room for supporting multiple PATCH styles in any given API, should this become desirable, without breaking existing clients.

URL parameters
--------------

- *Must*: Sweep complexity behind the ``?`` ::

    GET /dogs?color=red&state=running&location=park

- ``fields`` parameter - Allow clients to specify/filter the fields in the response by supporting a fields parameter as a comma-delimited list. ::

    /dogs?fields=name,color,location
    /dogs?fields=title,media:group(media:thumbnail)

- ``expand`` parameter - Allow clients to request including data from other resources using the expand parameter as explained further in the Expansion section.

.. todo: link to expansion section 

- ``requested_fields`` parameter - Allow clients to request additional optional fields that will be added to the response. ::

    GET /comment?requested_fields=author_profile_image,endorse_profile_image

- ``text_search`` parameter - Allow clients to perform text search

    global: ``/search?text_search=fluffy+fur``

    scoped: ``/owners/5678/dogs?text_search=fluffy+fur``

    formatted: ``/search.xml?text_search=fluffy+fur``

Errors
------

**HTTP status codes**

Use the appropriate value amongst the following (or document in the code why an exception is needed)

    200 - OK

    201 - Created

    204 - OK, no content returned (use for PATCH)

    304 - Not Modified

    400 - Bad Request

    401 - Unauthorized (for unauthenticated users)

    403 - Forbidden (for authenticated users who do not have the right permissions)

    404 - Not Found

    415 - Unsupported Media Type (used for PATCH if implementation is "merge patch" algorithm, and caller did not specify "application/merge-patch+json" content_type)

    500 - Internal Server Error


**Prevent information leakage**

    **Must**: Use 404 instead of 403 when the actual existence would be leaking information that we don't want


**Error description**

    **Must**: Be verbose and use plain language descriptions.
    **Must**: Use i18n for user facing messages ("user_message" in example below)
    **Nice**: Add as many hints as your API team can think of about what's causing an error.
    **Nice**: Add a link in your description to more information, like Twilio does.

**Error format**

    - ``developer_message`` (no i18n)
    - ``user_message`` (optional, but if provided, i18n as the expectation is that this may surface in a UI)
    - ``field_errors`` (if applicable)
    - ``error_code`` (for example: see LMS ``has_access`` interface design)
        *Include description in your REST API Docs.*

    ::

        {
            "error_code": "course_not_started"  # a short string that the client can rely upon for handling different errors
            "developer_message" : "Verbose, plain language description of the problem for the app developer with hints about how to fix it.",
            "user_message":"Pass this message on to the app user if needed.",
            "field_errors": {
                "foo": {
                    "developer_message": "",
                    "user_message": ""
                }
            }
        }


Versioning
----------

**Location**

- Put the version in the URL so the client can see it easily when handling the response logic.

- Exception: Put it in the header only if it doesn't change the response handling logic, like the OAuth endpoint.


**Numbering**

- *Must*: Versions are major only ex. ``/v0/`` ``/v1/`` ``/v2/``

- *Must*: Major version should only be updated when changing the existing contract in a way that breaks backwards compatibility.  The previous major version should continue to be supported for old clients according to the service's deprecation policy.

- *Must*: Additive changes to the contract of the API, or the results, should not bump the major version, unless those changes are non-optional, and break existing contracts with the API.


**Future considerations**

- (TODO) Responses should have a header containing minor / patch versions. 
    ``X-API-Version`` (TODO look into established convention for header name)

- Deprecation Process: varies from project to project based on product requirements and developer usage, client usage, etc. Should be well documented.
    TODO: deeper dive into Deprecation.

- Handling v0 APIs

Pagination
----------

We use the conventions established by `DRF <http://www.django-rest-framework.org/api-guide/pagination/#pagenumberpagination>`_, with some extra fields:

- ``next``: A URL to the next page, or null.
- ``previous``: A URL to the previous page, or null.
- ``count``: The total number of items.
- ``num_pages``: The total number of pages.
- ``results``: List of results.

The query parameters are as follows:

- ``page`` - the page of results (zero indexed)
- ``page_size`` - the number of results to return per page
- ``sort_order`` - a string indicating the desired order (no direction modifiers)

Documentation
-------------

Work with the Docs team to update the `edX platform API documentation <http://edx-platform-api.readthedocs.org/en/latest/>`_.

**Format**

Use `Swagger <http://swagger.io/specification/>`_ to generate API documentation where possible.

**Docstrings**

Following are our guidelines for Django Rest Framework API implementations.

edX API docstrings serve two purposes:

- They are interpreted by DRF to provide dynamic API documentation

    e.g. https://courses.edx.org/api/user/v1/accounts/AndyA

    See the DRF documentation for more details: http://tomchristie.github.io/rest-framework-2-docs/topics/documenting-your-api

- They are compiled by the Sphinx Napoleon extension to be included in our published API documentation set

    http://edx-platform-api.readthedocs.org/en/latest/

These two tools put constraints on the format of the docstring, so we developed the following compromise that should work for both:

- Add the endpoint documentation as a docstring on your DRF view class

    Note: individual method implementation docstrings are not currently used, but are still worth including for readers of the code.

- Use Markdown format, and do not include any HTML as it will render incorrectly in one or both tools

- Use double asterisks (bold) around headings

- Be careful with the indentation as the Sphinx generation for ReadTheDocs is very finicky

- Provide at least the following sections:

    Use Cases

    Example Requests

    Response Values for GET, Response Values for PUT etc if you implement multiple methods)


Here is a representative docstring (from https://github.com/edx/edx-platform/blob/master/common/djangoapps/enrollment/views.py#L67)::

    class EnrollmentView(APIView, ApiKeyPermissionMixIn):
        """
        **Use Cases**
     
            Get the user's enrollment status for a course.
     
        **Example Requests**:
     
            GET /api/enrollment/v1/enrollment/{user_id},{course_id}
     
        **Response Values**
     
            * created: The date the user account was created.
            * mode: The enrollment mode of the user in this course.
            * is_active: Whether the enrollment is currently active.
            * course_details: A collection that includes:
                * course_id: The unique identifier for the course.
                * enrollment_start: The date and time that users can begin enrolling in the course.
                  If null, enrollment opens immediately when the course is created.
                * enrollment_end: The date and time after which users cannot enroll for the course.  
                  If null, the enrollment period never ends.
                * course_start: The date and time at which the course opens.  If null, the course 
                  opens immediately when created.
                * course_end: The date and time at which the course closes.  If null, the course never ends.
                * course_modes: An array of data about the enrollment modes supported for the course. 
                    Each enrollment mode collection includes:
                    * slug: The short name for the enrollment mode.
                    * name: The full name of the enrollment mode.
                    * min_price: The minimum price for which a user can enroll in this mode.
                    * suggested_prices: A list of suggested prices for this enrollment mode.
                    * currency: The currency of the listed prices.
                    * expiration_datetime: The date and time after which users cannot enroll in the course in this mode.
                    * description: A description of this mode.
                * invite_only: Whether students must be invited to enroll in the course; true or false.
            * user: The ID of the user.
        """
        ...


Discoverability
---------------

- Use hyperlinks (with absolute URLs) to represent (primary/foreign) keys.

- When there are links to other resources, we should have a hyperlink in the response.


Multiple formats
----------------

- JSON as the default format

- Clients can request different formats by specifying the "Accept" header

- The server should always include a "Content-Type" header which specifies the format of the data being returned


Authentication
--------------

By convention, our REST APIs support the following two authentication schemes:

- OAuth2 - for mobile clients and micro-services
- Session-based authentication - for mobile webviews and browser clients 

Seralization
------------

Dates and Timestamps

- Should be serialized to strings in the `ISO 8601 <http://www.w3.org/TR/NOTE-datetime>`_ standard format
- Timestamps should include explicit timezone offsets
- UTC timestamps are preferred


Expansion
---------

APIs can support expanding related objects, e.g. the `team API <https://openedx.atlassian.net/wiki/display/TNL/Team+API>`_ optionally includes user profile information for each member.  This is preferable to requiring the client to make multiple subsequent AJAX calls.

There can be three levels for a related object (using ``username`` as an example):

    (a) Returning just the id::

            "username": "andya"

    (b) Returning an object containing the id and a URL to get more details::

            "user": {
              "username": "andya",
              "url": "https://openedx.example.com/api/user/v1/accounts/andya"
            }

    (c) Returning an object containing the expanded details::

            "user": {
              "username": "andya",
              "country": "UK",
              "profile_image": {
                "has_image": True,
                "image_url_full": "http://my-image-storage.net/media/profile_images/123456789_500.jpg",
                "image_url_large": "http://my-image-storage.net/media/profile_images/123456789_120.jpg",
                "image_url_medium": "http://my-image-storage.net/media/profile_images/123456789_50.jpg",
                "image_url_small": "http://my-image-storage.net/media/profile_images/123456789_30.jpg",
              },
              ...
            }

By default:

- For objects that have their own APIs, use option (b) and return both an id and a URL
- For other objects, use option (a) and just return the id
- Support a query parameter indicating an optional list of objects to be expanded: e.g. ``?expand=user,team``


Review process
--------------

At the moment, there is no formal review process for new APIs. Please work with the relevant maintainer team to determine if API changes make sense for your use case.

Rationale
=========

Our conventions were originally derived from a very useful set defined by `Apigee <http://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf>`_. Portions of that guide have been reused here.

Open edX is not the first project that has attempted to define API best practices. Here are some other organizations that have formalized their API practices:

- `Google <https://developers.google.com/+/api/>`_
- `Facebook <https://developers.facebook.com/docs/graph-api/reference/v2.2/profile>`_
- `Twitter <https://dev.twitter.com/rest/public>`_
- `LinkedIn <https://developer.linkedin.com/docs/rest-api>`_
- `StackExchange <https://api.stackexchange.com/>`_
- `Instagram <https://instagram.com/developer/>`_
- `Github <https://developer.github.com/v3/>`_
- `Salesforce <https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/intro_rest_resources.htm>`_


Backward Compatibility
=======================

Any web APIs that do not conform with these practices should be updated accordingly. This document is based on existing practices so we do not expect any new backwards compatibility issues.


Reference Implementation
========================

There are a number of existing APIs that you can crib from, for example:

    Discussion API: https://github.com/edx/edx-platform/tree/master/lms/djangoapps/discussion_api

    User API: https://github.com/edx/edx-platform/tree/master/openedx/core/djangoapps/user_api

Here are some representative URLs::

    /api/course/v1/courses/
    /api/enrollment/v1/enrollments/
    /api/discussion/v1/threads/{thread_id}/


Rejected Alternatives
=====================

See `this wiki page <https://openedx.atlassian.net/wiki/display/AC/API+Thoughts>`_ for the options and notes that led to the original version of this document.


Change History
==============

.. A list of dated sections that describes a brief summary of each revision of the OEP.
